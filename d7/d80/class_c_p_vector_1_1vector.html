<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPVector: CPVector::vector&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CPVector<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../de/da4/namespace_c_p_vector.html">CPVector</a></li><li class="navelem"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="../../d9/db7/class_c_p_vector_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CPVector::vector&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Cross Platform Vector class.  
 <a href="../../d7/d80/class_c_p_vector_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/dd2/_c_p_vector___template_8h_source.html">CPVector_Template.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:aa0e81e4f7ad196b6182a840a28afd0f0" id="r_aa0e81e4f7ad196b6182a840a28afd0f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#aa0e81e4f7ad196b6182a840a28afd0f0">vector</a> ()</td></tr>
<tr class="memdesc:aa0e81e4f7ad196b6182a840a28afd0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:aa0e81e4f7ad196b6182a840a28afd0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11babda2ce56da533d7933f1480c4d62" id="r_a11babda2ce56da533d7933f1480c4d62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a11babda2ce56da533d7933f1480c4d62">vector</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">count</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">value</a>=T())</td></tr>
<tr class="memdesc:a11babda2ce56da533d7933f1480c4d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize constructor.  <br /></td></tr>
<tr class="separator:a11babda2ce56da533d7933f1480c4d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab548aaa22a1d2be507026cf2dca9f6af" id="r_ab548aaa22a1d2be507026cf2dca9f6af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ab548aaa22a1d2be507026cf2dca9f6af">vector</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">other</a>)</td></tr>
<tr class="memdesc:ab548aaa22a1d2be507026cf2dca9f6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ab548aaa22a1d2be507026cf2dca9f6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bce583b8a4a93f1770451627c11a0a" id="r_ad9bce583b8a4a93f1770451627c11a0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad9bce583b8a4a93f1770451627c11a0a">vector</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T *<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">pointer</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">len</a>)</td></tr>
<tr class="memdesc:ad9bce583b8a4a93f1770451627c11a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ad9bce583b8a4a93f1770451627c11a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6580a48e9faebc3f9c2f7afed0bc78b8" id="r_a6580a48e9faebc3f9c2f7afed0bc78b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a6580a48e9faebc3f9c2f7afed0bc78b8">vector</a> (<a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">source</a>) <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">noexcept</a></td></tr>
<tr class="memdesc:a6580a48e9faebc3f9c2f7afed0bc78b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a6580a48e9faebc3f9c2f7afed0bc78b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432954574c5bec3757bf929902ee3ad" id="r_ac432954574c5bec3757bf929902ee3ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ac432954574c5bec3757bf929902ee3ad">~vector</a> ()</td></tr>
<tr class="memdesc:ac432954574c5bec3757bf929902ee3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ac432954574c5bec3757bf929902ee3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771b25dde5765409717f30cd3f64cecf" id="r_a771b25dde5765409717f30cd3f64cecf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a771b25dde5765409717f30cd3f64cecf">vector</a> (std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:a771b25dde5765409717f30cd3f64cecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::initializer list constructor (only available if CPVECTOR_USING_STD_VECTOR_ALLOCATION is enabled).  <br /></td></tr>
<tr class="separator:a771b25dde5765409717f30cd3f64cecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a36fb53f4d315f992a9576a802320a147" id="r_a36fb53f4d315f992a9576a802320a147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a36fb53f4d315f992a9576a802320a147">operator=</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">source</a>)</td></tr>
<tr class="memdesc:a36fb53f4d315f992a9576a802320a147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:a36fb53f4d315f992a9576a802320a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07450930d2903187a32de74a22b51b32" id="r_a07450930d2903187a32de74a22b51b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a07450930d2903187a32de74a22b51b32">operator=</a> (<a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp;&amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">source</a>)</td></tr>
<tr class="memdesc:a07450930d2903187a32de74a22b51b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Assignment operator.  <br /></td></tr>
<tr class="separator:a07450930d2903187a32de74a22b51b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ab40cecbea1efa2d5ff8f163d1358" id="r_aa67ab40cecbea1efa2d5ff8f163d1358"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#aa67ab40cecbea1efa2d5ff8f163d1358">operator[]</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">position</a>)</td></tr>
<tr class="memdesc:aa67ab40cecbea1efa2d5ff8f163d1358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript Array operator. This operator is used to reference the element present at position given inside the operator.  <br /></td></tr>
<tr class="separator:aa67ab40cecbea1efa2d5ff8f163d1358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfc763e458239b8d3bb3812e3bbd70a" id="r_acbfc763e458239b8d3bb3812e3bbd70a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#acbfc763e458239b8d3bb3812e3bbd70a">operator[]</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">position</a>) <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a></td></tr>
<tr class="memdesc:acbfc763e458239b8d3bb3812e3bbd70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript Array operator. This operator is used to reference the element present at position given inside the operator.  <br /></td></tr>
<tr class="separator:acbfc763e458239b8d3bb3812e3bbd70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73361c34ab076d378b61cc8314a8315" id="r_ac73361c34ab076d378b61cc8314a8315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ac73361c34ab076d378b61cc8314a8315">operator==</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">source</a>) <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a></td></tr>
<tr class="memdesc:ac73361c34ab076d378b61cc8314a8315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to. Checks if both vectors are equal in size and in contents, it is important that the class T has defined == amd != operators.  <br /></td></tr>
<tr class="separator:ac73361c34ab076d378b61cc8314a8315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3012bdc0d60556aaf238d397420e7d3" id="r_ad3012bdc0d60556aaf238d397420e7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad3012bdc0d60556aaf238d397420e7d3">operator!=</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">source</a>) <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a></td></tr>
<tr class="memdesc:ad3012bdc0d60556aaf238d397420e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not Equal to. Checks that both vectors doesn't have the same contents, it is important that the class T has defined == amd != operators.  <br /></td></tr>
<tr class="separator:ad3012bdc0d60556aaf238d397420e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Buffer Size And Resize API</div></td></tr>
<tr class="memitem:a4ff57fd3f382e068a1c59b3f8ec2a74f" id="r_a4ff57fd3f382e068a1c59b3f8ec2a74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f">capacity</a> () <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">noexcept</a></td></tr>
<tr class="memdesc:a4ff57fd3f382e068a1c59b3f8ec2a74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.  <br /></td></tr>
<tr class="separator:a4ff57fd3f382e068a1c59b3f8ec2a74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67efe663b1a16225c039e0c1c8db8ca" id="r_ad67efe663b1a16225c039e0c1c8db8ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca">size</a> () <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">noexcept</a></td></tr>
<tr class="memdesc:ad67efe663b1a16225c039e0c1c8db8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector.  <br /></td></tr>
<tr class="separator:ad67efe663b1a16225c039e0c1c8db8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8cc61ff6acd68211566704c3d3abe" id="r_a17d8cc61ff6acd68211566704c3d3abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a17d8cc61ff6acd68211566704c3d3abe">reserve</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">uint32_t</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">new_cap</a>)</td></tr>
<tr class="memdesc:a17d8cc61ff6acd68211566704c3d3abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the vector (the total number of elements that the vector can hold without requiring reallocation) to a value that's greater or equal to capacity.  <br /></td></tr>
<tr class="separator:a17d8cc61ff6acd68211566704c3d3abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6874b520e6e2637ae5043122f0f5e90" id="r_ae6874b520e6e2637ae5043122f0f5e90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ae6874b520e6e2637ae5043122f0f5e90">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ae6874b520e6e2637ae5043122f0f5e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the container to reduce its capacity to fit its size.  <br /></td></tr>
<tr class="separator:ae6874b520e6e2637ae5043122f0f5e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d06225e9ce24850ce5c7432abe471d" id="r_ad8d06225e9ce24850ce5c7432abe471d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad8d06225e9ce24850ce5c7432abe471d">resize</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">uint32_t</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">new_size</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">value</a>=T())</td></tr>
<tr class="memdesc:ad8d06225e9ce24850ce5c7432abe471d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain new_size elements, does nothing if new_size == <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a>.  <br /></td></tr>
<tr class="separator:ad8d06225e9ce24850ce5c7432abe471d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abd061eddf644b4cf2ddb35260d0bee" id="r_a8abd061eddf644b4cf2ddb35260d0bee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a8abd061eddf644b4cf2ddb35260d0bee">clear</a> ()</td></tr>
<tr class="memdesc:a8abd061eddf644b4cf2ddb35260d0bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the vector (which are destroyed), leaving the container with a size and capacity of 0.  <br /></td></tr>
<tr class="separator:a8abd061eddf644b4cf2ddb35260d0bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Core functionality</div></td></tr>
<tr class="memitem:a1f91897fc6d2be104e90111ae8c6133f" id="r_a1f91897fc6d2be104e90111ae8c6133f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a1f91897fc6d2be104e90111ae8c6133f">copy</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T *<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">source</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">len</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">Resize</a>=0)</td></tr>
<tr class="memdesc:a1f91897fc6d2be104e90111ae8c6133f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies len data elements from a buffer passed by pointer.  <br /></td></tr>
<tr class="separator:a1f91897fc6d2be104e90111ae8c6133f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81b14be27b14b335e0194e623300ca8" id="r_af81b14be27b14b335e0194e623300ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#af81b14be27b14b335e0194e623300ca8">push_back</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">value</a>)</td></tr>
<tr class="memdesc:af81b14be27b14b335e0194e623300ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <br /></td></tr>
<tr class="separator:af81b14be27b14b335e0194e623300ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c95a38a1d80daf76c1fd64878d57c26" id="r_a7c95a38a1d80daf76c1fd64878d57c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a7c95a38a1d80daf76c1fd64878d57c26">push_back</a> (T &amp;&amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">Rvalue</a>)</td></tr>
<tr class="memdesc:a7c95a38a1d80daf76c1fd64878d57c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <br /></td></tr>
<tr class="separator:a7c95a38a1d80daf76c1fd64878d57c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5a16414c525b88e3164e8adcf218a7" id="r_aaf5a16414c525b88e3164e8adcf218a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#aaf5a16414c525b88e3164e8adcf218a7">pop</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> index)</td></tr>
<tr class="memdesc:aaf5a16414c525b88e3164e8adcf218a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the element at a given index.  <br /></td></tr>
<tr class="separator:aaf5a16414c525b88e3164e8adcf218a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1032ac136f6a6871e738553abc5054cc" id="r_a1032ac136f6a6871e738553abc5054cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a1032ac136f6a6871e738553abc5054cc">pop_first</a> ()</td></tr>
<tr class="memdesc:a1032ac136f6a6871e738553abc5054cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the first elemnt.  <br /></td></tr>
<tr class="separator:a1032ac136f6a6871e738553abc5054cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8a4b5a387ea2819f0df8c47dc7c0e6" id="r_abc8a4b5a387ea2819f0df8c47dc7c0e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#abc8a4b5a387ea2819f0df8c47dc7c0e6">pop_back</a> ()</td></tr>
<tr class="memdesc:abc8a4b5a387ea2819f0df8c47dc7c0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the last elemnt.  <br /></td></tr>
<tr class="separator:abc8a4b5a387ea2819f0df8c47dc7c0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e521e9af0e9025447a6cf81d94ee49" id="r_aa0e521e9af0e9025447a6cf81d94ee49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#aa0e521e9af0e9025447a6cf81d94ee49">emplace</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">value</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">pos</a>)</td></tr>
<tr class="memdesc:aa0e521e9af0e9025447a6cf81d94ee49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos.  <br /></td></tr>
<tr class="separator:aa0e521e9af0e9025447a6cf81d94ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfeb4a3b4683f9b4608edffffd39a99" id="r_a5bfeb4a3b4683f9b4608edffffd39a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a5bfeb4a3b4683f9b4608edffffd39a99">emplace</a> (T &amp;&amp;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">value</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">pos</a>)</td></tr>
<tr class="memdesc:a5bfeb4a3b4683f9b4608edffffd39a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos.  <br /></td></tr>
<tr class="separator:a5bfeb4a3b4683f9b4608edffffd39a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03351d1ba099862494bb45d88feaeac" id="r_ad03351d1ba099862494bb45d88feaeac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad03351d1ba099862494bb45d88feaeac">swap</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">index_a</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">index_b</a>)</td></tr>
<tr class="memdesc:ad03351d1ba099862494bb45d88feaeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the elements at index_a and index_b.  <br /></td></tr>
<tr class="separator:ad03351d1ba099862494bb45d88feaeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81abd8ef5294a0c1e5acbc588616e7c3" id="r_a81abd8ef5294a0c1e5acbc588616e7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a81abd8ef5294a0c1e5acbc588616e7c3">erase</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> index)</td></tr>
<tr class="memdesc:a81abd8ef5294a0c1e5acbc588616e7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the element at the given index from the list, if index &gt;= size the method does nothing.  <br /></td></tr>
<tr class="separator:a81abd8ef5294a0c1e5acbc588616e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace813c8a3b96d8b535c171f4a92edb3d" id="r_ace813c8a3b96d8b535c171f4a92edb3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ace813c8a3b96d8b535c171f4a92edb3d">erase</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">first</a>, <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">last</a>)</td></tr>
<tr class="memdesc:ace813c8a3b96d8b535c171f4a92edb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the elements between both given indices.  <br /></td></tr>
<tr class="separator:ace813c8a3b96d8b535c171f4a92edb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sorting</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>In order for these to work the class T must have declared the &lt;, &gt;, and the == operators. </p>
</div></td></tr>
<tr class="memitem:a1e732c03942f8a2e82387a73c54ee763" id="r_a1e732c03942f8a2e82387a73c54ee763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a1e732c03942f8a2e82387a73c54ee763">sort</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d8/d90/group___sorting.html#gaddc107114797c4cf6550ecea6f855aaf">Sorting::Callback</a>&lt; T &gt; <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">CompareFunction</a>)</td></tr>
<tr class="memdesc:a1e732c03942f8a2e82387a73c54ee763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the contents of the container based on the compare function recieved.  <br /></td></tr>
<tr class="separator:a1e732c03942f8a2e82387a73c54ee763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3f16eaa7af0c9bd6c694e394c919b" id="r_a8fe3f16eaa7af0c9bd6c694e394c919b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a8fe3f16eaa7af0c9bd6c694e394c919b">sort</a> (<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../df/d77/class_c_p_vector_1_1_sorting_1_1_sorting_array.html">Sorting::SortingArray</a>&lt; T &gt; &amp;SortingArray)</td></tr>
<tr class="memdesc:a8fe3f16eaa7af0c9bd6c694e394c919b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the contents of the container based on the CPVector::Sorting::SortingArray&lt;T&gt; recieved.  <br /></td></tr>
<tr class="separator:a8fe3f16eaa7af0c9bd6c694e394c919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af839d7224cae4215c0e326eda96f932c" id="r_af839d7224cae4215c0e326eda96f932c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#af839d7224cae4215c0e326eda96f932c">sortAscending</a> ()</td></tr>
<tr class="memdesc:af839d7224cae4215c0e326eda96f932c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the contents of the container from smallest to largest.  <br /></td></tr>
<tr class="separator:af839d7224cae4215c0e326eda96f932c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed2cb566bc29241e91a5f36a63c72e4" id="r_a9ed2cb566bc29241e91a5f36a63c72e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a9ed2cb566bc29241e91a5f36a63c72e4">sortDescending</a> ()</td></tr>
<tr class="memdesc:a9ed2cb566bc29241e91a5f36a63c72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the contents of the container from largest to smallest.  <br /></td></tr>
<tr class="separator:a9ed2cb566bc29241e91a5f36a63c72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T&gt;<br />
class CPVector::vector&lt; T &gt;</div><p>Cross Platform Vector class. </p>
<p><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">CPVector::Vector&lt;T&gt;</a> is a sequence container that encapsulates dynamic size arrays.<br  />
The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.<br  />
<br  />
The storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> function. Extra memory can be returned to the system via a call to <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ae6874b520e6e2637ae5043122f0f5e90" title="Requests the container to reduce its capacity to fit its size.">shrink_to_fit()</a>[1].<br  />
<br  />
Reallocations are usually costly operations in terms of performance. The <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a17d8cc61ff6acd68211566704c3d3abe" title="Increase the capacity of the vector (the total number of elements that the vector can hold without re...">reserve()</a> function can be used to eliminate reallocations if the number of elements is known beforehand. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type to be used for the Dynamic Array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d3/d4e/_2examples_2_appending_data_8cpp-example.html#_a1">/examples/AppendingData.cpp</a>, <a class="el" href="../../d7/da6/_2examples_2_sorting_array_8cpp-example.html#_a7">/examples/SortingArray.cpp</a>, and <a class="el" href="../../dc/d4c/_2examples_2_sorting_data_8cpp-example.html#_a1">/examples/SortingData.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa0e81e4f7ad196b6182a840a28afd0f0" name="aa0e81e4f7ad196b6182a840a28afd0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e81e4f7ad196b6182a840a28afd0f0">&#9670;&#160;</a></span>vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the vector to have <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a> = 0, the Capacity value is undefined, it's value is only bigger than size at all times. In order to reduce the capacity of the vector see <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ae6874b520e6e2637ae5043122f0f5e90" title="Requests the container to reduce its capacity to fit its size.">shrink_to_fit()</a> or <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a8abd061eddf644b4cf2ddb35260d0bee" title="Removes all elements from the vector (which are destroyed), leaving the container with a size and cap...">clear()</a>. </p>

</div>
</div>
<a id="a11babda2ce56da533d7933f1480c4d62" name="a11babda2ce56da533d7933f1480c4d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11babda2ce56da533d7933f1480c4d62">&#9670;&#160;</a></span>vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize constructor. </p>
<p>Resizes the container to contain count elements, does nothing if count == 0.<br  />
<br  />
If value parameter is not given additional default-inserted elements are appended<br  />
 If value parameter is given additional copies of value are appended.<br  />
</p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">count</td><td>New size of the conatainer </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize the elements with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab548aaa22a1d2be507026cf2dca9f6af" name="ab548aaa22a1d2be507026cf2dca9f6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab548aaa22a1d2be507026cf2dca9f6af">&#9670;&#160;</a></span>vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9bce583b8a4a93f1770451627c11a0a" name="ad9bce583b8a4a93f1770451627c11a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bce583b8a4a93f1770451627c11a0a">&#9670;&#160;</a></span>vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of an array of objects of type T. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pointer</td><td>location of the data to copy </td></tr>
    <tr><td class="paramname">len</td><td>number of elements to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6580a48e9faebc3f9c2f7afed0bc78b8" name="a6580a48e9faebc3f9c2f7afed0bc78b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6580a48e9faebc3f9c2f7afed0bc78b8">&#9670;&#160;</a></span>vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the copy of the contents of other </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pointer</td><td>location of the data to copy </td></tr>
    <tr><td class="paramname">len</td><td>number of elements to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac432954574c5bec3757bf929902ee3ad" name="ac432954574c5bec3757bf929902ee3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac432954574c5bec3757bf929902ee3ad">&#9670;&#160;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::~<a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Destroys all the elements amd changes the size and capacity to 0. (Releases the used memory) </p>

</div>
</div>
<a id="a771b25dde5765409717f30cd3f64cecf" name="a771b25dde5765409717f30cd3f64cecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771b25dde5765409717f30cd3f64cecf">&#9670;&#160;</a></span>vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::initializer list constructor (only available if CPVECTOR_USING_STD_VECTOR_ALLOCATION is enabled). </p>
<p>Constructs the container with an initializer list </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">list</td><td>std::initializer list with matching template argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ff57fd3f382e068a1c59b3f8ec2a74f" name="a4ff57fd3f382e068a1c59b3f8ec2a74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff57fd3f382e068a1c59b3f8ec2a74f">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">size_t</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. </p>
<p>This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity does not suppose a limit on the size of the vector. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space). The theoretical limit on the size of a vector is given by member max_size. The capacity of a vector can be explicitly altered by calling member <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a17d8cc61ff6acd68211566704c3d3abe" title="Increase the capacity of the vector (the total number of elements that the vector can hold without re...">vector::reserve</a>. </p>

</div>
</div>
<a id="a8abd061eddf644b4cf2ddb35260d0bee" name="a8abd061eddf644b4cf2ddb35260d0bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abd061eddf644b4cf2ddb35260d0bee">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the vector (which are destroyed), leaving the container with a size and capacity of 0. </p>
<p>if ( capacity &gt; 0 ) A reallocation is guaranteed to happen, and the vector capacity is guaranteed to change due to calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d3/d4e/_2examples_2_appending_data_8cpp-example.html#a4">/examples/AppendingData.cpp</a>, <a class="el" href="../../d7/da6/_2examples_2_sorting_array_8cpp-example.html#a11">/examples/SortingArray.cpp</a>, and <a class="el" href="../../dc/d4c/_2examples_2_sorting_data_8cpp-example.html#a5">/examples/SortingData.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1f91897fc6d2be104e90111ae8c6133f" name="a1f91897fc6d2be104e90111ae8c6133f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f91897fc6d2be104e90111ae8c6133f">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a>&#160;</td>
          <td class="paramname"><em>Resize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies len data elements from a buffer passed by pointer. </p>
<p>The vector can call resize(len) is Resize = 1. If after the operation the new <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a> is greater than old <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">end()</a> iterator) and all references to the elements are invalidated. Otherwise only the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">end()</a> iterator is invalidated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source</td><td>pointer to the first element to copy. </td></tr>
    <tr><td class="paramname">len</td><td>The number of elements to copy. </td></tr>
    <tr><td class="paramname">Resize</td><td>if Resize = 1, the vector resizes to make <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a> = len. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e521e9af0e9025447a6cf81d94ee49" name="aa0e521e9af0e9025447a6cf81d94ee49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e521e9af0e9025447a6cf81d94ee49">&#9670;&#160;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. </p>
<p>The element is inserted </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>The value of the element to append. </td></tr>
    <tr><td class="paramname">pos</td><td>Index where the element will be appended append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bfeb4a3b4683f9b4608edffffd39a99" name="a5bfeb4a3b4683f9b4608edffffd39a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfeb4a3b4683f9b4608edffffd39a99">&#9670;&#160;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. </p>
<p>The element is inserted </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>The value of the element to append. </td></tr>
    <tr><td class="paramname">pos</td><td>Index where the element will be appended append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace813c8a3b96d8b535c171f4a92edb3d" name="ace813c8a3b96d8b535c171f4a92edb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace813c8a3b96d8b535c171f4a92edb3d">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the elements between both given indices. </p>
<p>The elements are destroyed and erased. The elemnts erased include (this*)[first] and (this*)[last]. If (last&lt;=first) or (first&gt;=<a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a>) the method does nothing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">first</td><td>The index of the first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>The index of the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81abd8ef5294a0c1e5acbc588616e7c3" name="a81abd8ef5294a0c1e5acbc588616e7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81abd8ef5294a0c1e5acbc588616e7c3">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the element at the given index from the list, if index &gt;= size the method does nothing. </p>
<p>The element is destroyed and erased. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>The index of the element to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3012bdc0d60556aaf238d397420e7d3" name="ad3012bdc0d60556aaf238d397420e7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3012bdc0d60556aaf238d397420e7d3">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not Equal to. Checks that both vectors doesn't have the same contents, it is important that the class T has defined == amd != operators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source</td><td>Another container of the same type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36fb53f4d315f992a9576a802320a147" name="a36fb53f4d315f992a9576a802320a147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb53f4d315f992a9576a802320a147">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp; <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">::operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>This operator is used to assign new contents to the container by replacing the existing contents. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source</td><td>Another container of the same type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07450930d2903187a32de74a22b51b32" name="a07450930d2903187a32de74a22b51b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07450930d2903187a32de74a22b51b32">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a> &amp; <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">::operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Assignment operator. </p>
<p>This operator is used to assign new contents to the container by replacing the existing contents. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source</td><td>Another container of the same type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac73361c34ab076d378b61cc8314a8315" name="ac73361c34ab076d378b61cc8314a8315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73361c34ab076d378b61cc8314a8315">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal to. Checks if both vectors are equal in size and in contents, it is important that the class T has defined == amd != operators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source</td><td>Another container of the same type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa67ab40cecbea1efa2d5ff8f163d1358" name="aa67ab40cecbea1efa2d5ff8f163d1358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67ab40cecbea1efa2d5ff8f163d1358">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">::operator</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript Array operator. This operator is used to reference the element present at position given inside the operator. </p>
<p>It is similar to the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">at()</a> function, the only difference is that the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">at()</a> function throws an out-of-range exception when the position is not in the bounds of the size of vector, while this operator causes undefined behavior. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">position</td><td>Position of the element to be fetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbfc763e458239b8d3bb3812e3bbd70a" name="acbfc763e458239b8d3bb3812e3bbd70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfc763e458239b8d3bb3812e3bbd70a">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp; <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">::operator</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript Array operator. This operator is used to reference the element present at position given inside the operator. </p>
<p>It is similar to the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">at()</a> function, the only difference is that the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">at()</a> function throws an out-of-range exception when the position is not in the bounds of the size of vector, while this operator causes undefined behavior. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">position</td><td>Position of the element to be fetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf5a16414c525b88e3164e8adcf218a7" name="aaf5a16414c525b88e3164e8adcf218a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5a16414c525b88e3164e8adcf218a7">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the element at a given index. </p>
<p>When you call this method with index &gt;= <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a>, it leads to undefined behavior. The C++ standard does not specify what should happen in this scenario. Attempting to remove an element from an empty container is an error and can cause the program to crash or produce incorrect results. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>the value of the element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc8a4b5a387ea2819f0df8c47dc7c0e6" name="abc8a4b5a387ea2819f0df8c47dc7c0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8a4b5a387ea2819f0df8c47dc7c0e6">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the last elemnt. </p>
<p>When you call this method on an empty vector, it leads to undefined behavior. The C++ standard does not specify what should happen in this scenario. Attempting to remove an element from an empty container is an error and can cause the program to crash or produce incorrect results. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>The value of the element to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the poped value </dd></dl>

</div>
</div>
<a id="a1032ac136f6a6871e738553abc5054cc" name="a1032ac136f6a6871e738553abc5054cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1032ac136f6a6871e738553abc5054cc">&#9670;&#160;</a></span>pop_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::pop_first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the first elemnt. </p>
<p>When you call this method on an empty vector, it leads to undefined behavior. The C++ standard does not specify what should happen in this scenario. Attempting to remove an element from an empty container is an error and can cause the program to crash or produce incorrect results. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>the value of the element to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the poped value </dd></dl>

</div>
</div>
<a id="af81b14be27b14b335e0194e623300ca8" name="af81b14be27b14b335e0194e623300ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81b14be27b14b335e0194e623300ca8">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<p>If after the operation the new <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a> is greater than old <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> a reallocation takes place. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>the value of the element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c95a38a1d80daf76c1fd64878d57c26" name="a7c95a38a1d80daf76c1fd64878d57c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c95a38a1d80daf76c1fd64878d57c26">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>Rvalue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<p>If after the operation the new <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a> is greater than old <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> a reallocation takes place. The class used must implement the proper move semantics in order for this method to be able to call a move assignment operator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value</td><td>the value of the element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17d8cc61ff6acd68211566704c3d3abe" name="a17d8cc61ff6acd68211566704c3d3abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d8cc61ff6acd68211566704c3d3abe">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">uint32_t</a>&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the vector (the total number of elements that the vector can hold without requiring reallocation) to a value that's greater or equal to capacity. </p>
<p>If new_cap is greater than the current <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a>, new storage is allocated, otherwise the function does nothing.<br  />
<a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a17d8cc61ff6acd68211566704c3d3abe" title="Increase the capacity of the vector (the total number of elements that the vector can hold without re...">reserve()</a> does not change the size of the vector.<br  />
If after the operation the new <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a> is greater than old <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">end()</a> iterator) and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.<br  />
After a call to <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a17d8cc61ff6acd68211566704c3d3abe" title="Increase the capacity of the vector (the total number of elements that the vector can hold without re...">reserve()</a>, insertions will not trigger reallocation unless the insertion would make the size of the vector greater than the value of <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#a4ff57fd3f382e068a1c59b3f8ec2a74f" title="Returns the size of the storage space currently allocated for the vector, expressed in terms of eleme...">capacity()</a>.<br  />
If an allocation fails and exceptions are enabled (CPVECTOR_EXCEPTIONS_ENABLED), then the method throws a <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e" title="Template alias to remove the reference from a type.">CPVector::bad_allocation</a> exception.<br  />
 </p>

</div>
</div>
<a id="ad8d06225e9ce24850ce5c7432abe471d" name="ad8d06225e9ce24850ce5c7432abe471d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d06225e9ce24850ce5c7432abe471d">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">bool</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">uint32_t</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain new_size elements, does nothing if new_size == <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html#ad67efe663b1a16225c039e0c1c8db8ca" title="Returns the number of elements in the vector.">size()</a>. </p>
<p>If the current size is greater than new_size, the container is reduced to to fit new_size elements.<br  />
If the current size is less than count and value parameter is unused, then additional default-inserted elements are appended. If the current size is less than count and value parameter is used, then additional copies of value are appended. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">new_size</td><td>New size of the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize the new elements with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d3/d4e/_2examples_2_appending_data_8cpp-example.html#a2">/examples/AppendingData.cpp</a>, <a class="el" href="../../d7/da6/_2examples_2_sorting_array_8cpp-example.html#a8">/examples/SortingArray.cpp</a>, and <a class="el" href="../../dc/d4c/_2examples_2_sorting_data_8cpp-example.html#a2">/examples/SortingData.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae6874b520e6e2637ae5043122f0f5e90" name="ae6874b520e6e2637ae5043122f0f5e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6874b520e6e2637ae5043122f0f5e90">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the container to reduce its capacity to fit its size. </p>
<p>The request is non-binding, and the container implementation is free to optimize otherwise and leave the vector with a capacity greater than its size.<br  />
This may cause a reallocation, but has no effect on the vector size and cannot alter its elements. <br  />
 </p>

</div>
</div>
<a id="ad67efe663b1a16225c039e0c1c8db8ca" name="ad67efe663b1a16225c039e0c1c8db8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67efe663b1a16225c039e0c1c8db8ca">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">size_t</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. </p>
<p>This is the number of actual objects held in the vector, which is not necessarily equal to its storage capacity. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d3/d4e/_2examples_2_appending_data_8cpp-example.html#a3">/examples/AppendingData.cpp</a>, <a class="el" href="../../d7/da6/_2examples_2_sorting_array_8cpp-example.html#a9">/examples/SortingArray.cpp</a>, and <a class="el" href="../../dc/d4c/_2examples_2_sorting_data_8cpp-example.html#a3">/examples/SortingData.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1e732c03942f8a2e82387a73c54ee763" name="a1e732c03942f8a2e82387a73c54ee763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e732c03942f8a2e82387a73c54ee763">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../d8/d90/group___sorting.html#gaddc107114797c4cf6550ecea6f855aaf">Sorting::Callback</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>CompareFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the contents of the container based on the compare function recieved. </p>
<p>The elements are moved based on CompareFunction, in order to see an example definition of a comparing function see <a class="el" href="../../d8/d90/group___sorting.html#gab9c9e09b0d4e6aa8e6cfc65a3fa6a1bd" title="Template function that enables sorting elements in an descending manner.">CPVector::Sorting::Descending&lt;T&gt;</a> and <a class="el" href="../../d8/d90/group___sorting.html#gac273d7b2d9a2127b6c84c9e86d005b6e" title="Template function that enables sorting elements in an ascending manner.">CPVector::Sorting::Ascending&lt;T&gt;</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareFunction</td><td>Function to be used to compare values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d7/da6/_2examples_2_sorting_array_8cpp-example.html#a10">/examples/SortingArray.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8fe3f16eaa7af0c9bd6c694e394c919b" name="a8fe3f16eaa7af0c9bd6c694e394c919b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe3f16eaa7af0c9bd6c694e394c919b">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">const</a> <a class="el" href="../../df/d77/class_c_p_vector_1_1_sorting_1_1_sorting_array.html">Sorting::SortingArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>SortingArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the contents of the container based on the CPVector::Sorting::SortingArray&lt;T&gt; recieved. </p>
<p>The elements are moved based on a CPVector::Sorting::SortingArray&lt;T&gt;, which is an ordered list of comparing functions, this to achieve multi level sorting. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">laSortingArrayst</td><td>Ordered list containing the sort configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af839d7224cae4215c0e326eda96f932c" name="af839d7224cae4215c0e326eda96f932c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af839d7224cae4215c0e326eda96f932c">&#9670;&#160;</a></span>sortAscending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::sortAscending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the contents of the container from smallest to largest. </p>
<p>The elements are moved based on CPVector::Sorting::Asscending&lt;T&gt;. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../dc/d4c/_2examples_2_sorting_data_8cpp-example.html#a4">/examples/SortingData.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9ed2cb566bc29241e91a5f36a63c72e4" name="a9ed2cb566bc29241e91a5f36a63c72e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed2cb566bc29241e91a5f36a63c72e4">&#9670;&#160;</a></span>sortDescending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::sortDescending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the contents of the container from largest to smallest. </p>
<p>The elements are moved based on <a class="el" href="../../d8/d90/group___sorting.html#gab9c9e09b0d4e6aa8e6cfc65a3fa6a1bd" title="Template function that enables sorting elements in an descending manner.">CPVector::Sorting::Descending&lt;T&gt;</a>. </p>

</div>
</div>
<a id="ad03351d1ba099862494bb45d88feaeac" name="ad03351d1ba099862494bb45d88feaeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03351d1ba099862494bb45d88feaeac">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">void</a> <a class="el" href="../../d7/d80/class_c_p_vector_1_1vector.html">CPVector::vector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">unsigned</a> <a class="el" href="../../de/da4/namespace_c_p_vector.html#a67f831c080a7c5530161eb692014ae2e">int</a>&#160;</td>
          <td class="paramname"><em>index_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the elements at index_a and index_b. </p>
<p>The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. The class used must implement the proper move semantics in order for this method to be able to call a move assignment operator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index_a</td><td>the value of the first element to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="../../d1/dd2/_c_p_vector___template_8h_source.html">CPVector_Template.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
